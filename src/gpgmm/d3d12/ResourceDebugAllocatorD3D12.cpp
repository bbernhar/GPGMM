// Copyright 2021 The GPGMM Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "gpgmm/d3d12/ResourceDebugAllocatorD3D12.h"

#include "gpgmm/common/Log.h"
#include "gpgmm/common/Utils.h"
#include "gpgmm/d3d12/BackendD3D12.h"
#include "gpgmm/d3d12/ErrorD3D12.h"
#include "gpgmm/d3d12/ResourceAllocationD3D12.h"
#include "gpgmm/d3d12/SerializerD3D12.h"

namespace gpgmm { namespace d3d12 {

    namespace {
        // Returns error HR if the debug layer is not available.
        HRESULT ConfigureDeviceForLeakChecks(ComPtr<ID3D12Device> device) {
            ComPtr<ID3D12InfoQueue> leakMessageQueue;
            ReturnIfFailed(device.As(&leakMessageQueue));

            D3D12_INFO_QUEUE_FILTER emptyFilter{};
            ReturnIfFailed(leakMessageQueue->PushRetrievalFilter(&emptyFilter));
            return S_OK;
        }
    }  // namespace

    // static
    HRESULT DebugResourceAllocator::CreateAllocator(
        ComPtr<ID3D12Device> device,
        DebugResourceAllocator** debugResourceAllocator) {
        ReturnIfFailed(ConfigureDeviceForLeakChecks(device));

        *debugResourceAllocator = new DebugResourceAllocator(device);
        return S_OK;
    }

    DebugResourceAllocator::DebugResourceAllocator(ComPtr<ID3D12Device> device) : mDevice(device) {
    }

    DebugResourceAllocator::~DebugResourceAllocator() {
        for (auto& allocation : mTrackedLiveAllocations) {
            gpgmm::WarningLog() << "Live ResourceAllocation: "
                                << "Addr=" << ToString(allocation) << ", "
                                << "ExtRef=" << allocation->GetRefCount() << ","
                                << "Info="
                                << Serializer::Serialize(allocation->GetInfo()).ToString();
        }

        // TODO: Report details on leaked allocations.
        ASSERT(SUCCEEDED(CheckForDeviceObjectLeaks()));
    }

    // Returns E_FAIL if a device leak is detected.
    HRESULT DebugResourceAllocator::CheckForDeviceObjectLeaks() const {
        // Debug layer was never enabled.
        ComPtr<ID3D12DebugDevice> debugDevice;
        if (FAILED(mDevice.As(&debugDevice))) {
            return S_OK;
        }

        const D3D12_RLDO_FLAGS rldoFlags = D3D12_RLDO_DETAIL | D3D12_RLDO_IGNORE_INTERNAL;
        ReturnIfFailed(debugDevice->ReportLiveDeviceObjects(rldoFlags));

        ComPtr<ID3D12InfoQueue> leakMessageQueue;
        ReturnIfFailed(mDevice.As(&leakMessageQueue));

        // Count the reported live device objects messages that could be generated by GPGMM.
        // This is because the allowList filter cannot easily be made exclusive to these IDs.
        uint64_t totalLiveObjects = 0;
        for (uint64_t i = 0; i < leakMessageQueue->GetNumStoredMessagesAllowedByRetrievalFilter();
             ++i) {
            SIZE_T messageLength = 0;
            ReturnIfFailed(leakMessageQueue->GetMessage(i, nullptr, &messageLength));

            std::unique_ptr<uint8_t[]> messageData(new uint8_t[messageLength]);
            D3D12_MESSAGE* message = reinterpret_cast<D3D12_MESSAGE*>(messageData.get());
            ReturnIfFailed(leakMessageQueue->GetMessage(i, message, &messageLength));

            switch (message->ID) {
                case D3D12_MESSAGE_ID_LIVE_HEAP:
                case D3D12_MESSAGE_ID_LIVE_RESOURCE: {
                    totalLiveObjects++;
                } break;
                default:
                    break;
            }
        }

        leakMessageQueue->PopRetrievalFilter();
        return (totalLiveObjects > 0u) ? E_FAIL : S_OK;
    }

    void DebugResourceAllocator::TrackAllocation(ResourceAllocation* allocation) {
        const bool success = mTrackedLiveAllocations.insert(allocation).second;
        ASSERT(success);
    }

    void DebugResourceAllocator::DeallocateMemory(MemoryAllocation* allocation) {
        const bool success = mTrackedLiveAllocations.erase(ToBackend(allocation));
        ASSERT(success);
        allocation->GetAllocator()->DeallocateMemory(allocation);
    }

}}  // namespace gpgmm::d3d12
